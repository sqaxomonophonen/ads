#include lib.4st

: test_arithmetic
   2 3 +   5 = assert
   6 2 -   4 = assert
   2 3 *   6 = assert
   6 2 /   3 = assert
   5 3 %   2 = assert
   3 4 ^  81 = assert
;

: test_math
   1764 sqrt  42 = assert
   0    cos    1 = assert
   1024 log2  10 = assert
   420 neg abs 420 = assert

   55 1 neg e10   floor   5 = assert
   55 1 neg e10   ceil    6 = assert
   54 1 neg e10   round   5 = assert
   56 1 neg e10   round   6 = assert
;

: test_numbers
   : pi
      314159 5 neg e10
   ;

   : test_pi ( also a meta test of nested tests : )
      pi 3 gt assert
      pi 4 lt assert
      pi cos    9999 neg 4 neg e10   lt assert
      pi cos   10000 neg 4 neg e10   gt assert
   ;
;

: test_branches
   : branch
      if 420 else 666 endif
   ;
   1 branch  420 = assert
   0 branch  666 = assert

   : nested
      if
         if 1 else 2 endif
      else
         if 3 else 4 endif
      endif
   ;

   1 1 nested    1 = assert
   0 1 nested    2 = assert
   1 0 nested    3 = assert
   0 0 nested    4 = assert
   3 2 nested    1 = assert

   ( test "if without else" )

   69    1 if 2 endif    2 = assert drop
   69    0 if 2 endif   69 = assert
;

: test_times_loop
   ( XXX should "0 times" be a thing? it would complicate the VM... )
   2   1 times dup * loop       4 = assert
   2   2 times dup * loop      16 = assert
   2   3 times dup * loop     256 = assert
   2   4 times dup * loop   65536 = assert

   ( nested times/loop )
   4
   3 times
      4 times
         dup +
      loop
      11 -
   loop
   13381 = assert
;


: test_do_while
   1
   do
      2 *
   dup 5000 lt while
   8192 = assert
;

: test_word_tables

   ( "api_three" is the only word that doesn't "blow up" when called. it's part
   of a "word table" (double-colon prefix) which is good for "indirect calls" )

   :: api_one 0 assert ;
   :: api_two 0 assert ;
   :: api_three 1 assert 42 ;
   :: api_four 0 assert ;

   : not_this_one 0 assert;

   api_three            42 = assert
   api_three            42 = assert
   `api_three call      42 = assert
   `api_two 1 + call    42 = assert
   `api_one 2 + call    42 = assert
   `api_four 1 - call   42 = assert
;

: test_recursion
   : gcd ( greatest common divisor done in recursive style, just to test recursion )
      ( a b )
      dup 0 = if
         drop return ( return a )
      else
         dup      ( -- a b b)
         rot      ( -- b a b)
         %        ( -- b a%b)
         gcd
      endif
   ;
   10 15 gcd    5 = assert
   3  4  gcd    1 = assert
   3  4  gcd    1 = assert
   55 66 gcd   11 = assert
;

: test_rotations
   1 2         swap     ( ab   -- ba )    1 = assert  2 = assert
   1 2       2 nrot     ( ab   -- ba )    1 = assert  2 = assert
   1 2 3       rot      ( abc  -- bca )   1 = assert  3 = assert  2 = assert
   1 2 3     3 nrot     ( abc  -- bca )   1 = assert  3 = assert  2 = assert
   1 2 3 4   4 nrot     ( abcd -- bcda )  1 = assert  4 = assert  3 = assert  2 = assert
   1 2 3       tro      ( abc  -- cab )   2 = assert  1 = assert  3 = assert
   1 2 3 4   4 ntro     ( abcd -- dabc )  3 = assert  2 = assert  1 = assert  4 = assert
;

: test_arrays
   arrnew                        arrlen 0 = assert                                          drop

   : mkarr
      arrnew   5 arrpush 6 arrpush 7 arrpush
      arrlen 3 = assert
   ;

   mkarr
   arrpop 7 = assert     arrpop 6 = assert     arrpop 5 = assert
   drop

   mkarr
   arrshift 5 = assert   arrshift 6 = assert   arrshift 7 = assert
   drop

   mkarr
   0 arrget 5 = assert
   1 arrget 6 = assert
   2 arrget 7 = assert
   drop

   mkarr
   0 42 arrset
   2 69 arrset
   0 arrget 42 = assert
   1 arrget  6 = assert
   2 arrget 69 = assert
   drop

   arrnew
   69 arrunshift
   42 arrunshift
   11 arrunshift
   0 arrget 11 = assert
   1 arrget 42 = assert
   2 arrget 69 = assert
   drop

   mkarr
   arrnew 69 arrpush 42 arrpush
   arrjoin
   mkarr
   arrjoin
   0 arrget 5 = assert
   1 arrget 6 = assert
   2 arrget 7 = assert
   3 arrget 69 = assert
   4 arrget 42 = assert
   5 arrget 5 = assert
   6 arrget 6 = assert
   7 arrget 7 = assert
   drop

   mkarr mkarr arrjoin
   4 arrsplit
   arrlen 2 = assert
   0 arrget 6 = assert
   1 arrget 7 = assert
   drop
   arrlen 4 = assert
   0 arrget 5 = assert
   1 arrget 6 = assert
   2 arrget 7 = assert
   3 arrget 5 = assert
   drop
;

: test_performance
   : n 5 4 e10 ;
   0
   n times 1 + loop
   n = assert
;
